% Generated by MATLAB(R) 24.2 (R2024b) and Radar Toolbox 24.2 (R2024b).
% Generated on: 25-Apr-2025 12:11:09

%% Set up radar, target, and environment structures for the currently selected radar
% Radar design parameters
radar = designRadar('AirportRadar');

% Radar environment
env = radarEnvironment();

% Radar target
rangeLimits = [1.00000e-02 2.00000e+04]; % m
target = radarTarget(radar,env,rangeLimits);

%% Define constraints and design requirements
% Constrain analysis in range
constraint.Range = 1.8000e+04; % m

% Set design requirements
PdThreshold = 7.5000e-01; % Decimal
PdObjective = 9.0000e-01; % Decimal
% Calculate propagation factor
Fprop = propagationFactor(radar,target);

% Calculate environmental losses
[Lgas,Llens,Lprecipitation] = atmosphericLosses(radar,env,target);
Latmos = sum([Lgas Llens Lprecipitation], 2);

% Calculate range-dependent factors
Fcustom = rangeDependentLosses(radar,target);


%% Compute available SNR for the currently selected radar
% Calculate signal-to-noise ratio (SNR)
availableSNR = radareqsnr(radar.Wavelength,target.ranges,radar.PeakPower, ...
    radar.Pulsewidth,'Gain',radar.Gain,'RCS',target.RCS,'Ts',radar.SystemTemperature, ...
    'PropagationFactor',Fprop,'AtmosphericLoss',Latmos,'CustomFactor',Fcustom); % dB

%% Calculate detectability
requiredPd = [PdThreshold PdObjective]; % Decimal
[Dx,Dc,componentNames] = effectiveDetectability(requiredPd,radar,target);

% Probability of detection as a function of target range
probabilityGrid = probgrid(0.1,1-1e-6,100);
requiredSNR = effectiveDetectability(probabilityGrid,radar,target);
[~, idx] = unique(requiredSNR);
idxNotInf = ~isinf(availableSNR);
availablePd = zeros(size(availableSNR));
if any(idxNotInf)
    availablePd(idxNotInf) = rocinterp(requiredSNR(idx),probabilityGrid(idx),availableSNR(idxNotInf),'snr-pd');
end
availablePd(availableSNR > requiredSNR(end)) = 1;
availablePd(availableSNR < requiredSNR(1)) = 0;


%% Generate signal-to-noise (SNR) ratio versus range plot
figure('Name','SNR vs Range');
hAxes = gca;
detect = Dx(2); % dB
detectThreshold = Dx(1); % dB
maxRange = constraint.Range;
radarmetricplot(target.ranges*1.0000e-03,availableSNR,detect,detectThreshold, ...
    'MaxRangeRequirement',maxRange*1.0000e-03, ...
    'RadarName',{radar.Name}, ...
    'MetricName','SNR', ...
    'RequirementName','Detectability', ...
    'RangeUnit','km', ...
    'MetricUnit','dB', ...
    'ShowStoplight',true, ...
    'Parent',hAxes);


%% Generate probability of detection versus range plot
figure('Name','Pd vs Range');
hAxes = gca;
maxRange = constraint.Range;
radarmetricplot(target.ranges*1.0000e-03,availablePd,PdObjective,PdThreshold, ...
    'MaxRangeRequirement',maxRange*1.0000e-03, ...
    'RadarName',{radar.Name}, ...
    'MetricName','Probability of Detection', ...
    'RequirementName','Pd', ...
    'RangeUnit','km', ...
    'ShowStoplight',true, ...
    'Parent',hAxes);
ylim(hAxes,[0.1 1.04]);


%% Generate link budget plot
figure('Name','Link Budget');
subplot(2,1,1);
radarbudgetplot(Dc(2,:), componentNames);
title(['Objective Detectability ' sprintf('(P_d=%.2f)', PdObjective)]);

subplot(2,1,2);
radarbudgetplot(Dc(1,:), componentNames);
title(['Threshold Detectability ' sprintf('(P_d=%.2f)', PdThreshold)]);


%% Generate environmental losses plot
Fprop = sum(Fprop,2);
figure('Name','Environmental Losses');
ax = subplot(4, 1, 1);
plot(target.ranges*1.0000e-03,Fprop,'LineWidth',2,'Tag','Lossfactor_1');
title('Radar Propagation Factor');
ylabel('(dB)');
grid on;
setYLims(ax,Fprop);

ax = subplot(4, 1, 2);
plot(target.ranges*1.0000e-03,Lprecipitation,'LineWidth',2,'Tag','Lossfactor_1');
title('Precipitation Loss');
ylabel('(dB)');
grid on;
setYLims(ax,Lprecipitation);

ax = subplot(4, 1, 3);
plot(target.ranges*1.0000e-03,Llens,'LineWidth',2,'Tag','Lossfactor_1');
title('Lens Effect Loss');
ylabel('(dB)');
grid on;
setYLims(ax,Llens);

ax = subplot(4, 1, 4);
plot(target.ranges*1.0000e-03,Lgas,'LineWidth',2,'Tag','Lossfactor_1');
title('Atmospheric Gas Loss');
ylabel('(dB)');
grid on;
setYLims(ax,Lgas);

xlabel('Target Range (km)');

%% Local Functions
% Radar design parameters
function radar = designRadar(radarName)
radar.Name = radarName;
radar.AzimuthBeamwidth = [2;2];
radar.DutyCycle = 1.40000e-02;
radar.ElevationBeamwidth = [6;6];
radar.Frequency = 9500000000; % Hz
radar.Gain = [34.3136,34.3136];
radar.Height = 10; % m
radar.MNumCPIs = 1;
radar.MaxSpeed = 5.52249e+01;
radar.NoiseTemperature = 950;
radar.NumCPIs = 3;
radar.NumCoherentPulses = 30;
radar.NumNonCoherentPulses = 1;
radar.PRF = 7000; % Hz
radar.PeakPower = 2000; % W
radar.Pfa = 1.00000e-06;
radar.Polarization = 'H';
radar.PolarizationAngle = 0;
radar.PulseBandwidth = 5000000; % Hz
radar.Pulsewidth = 2.00000e-06; % s
radar.RangeRateRes = 3.68166e+00;
radar.ReferenceNoiseTemperature = 290;
radar.ScanRate = 1.55556e+02; % deg/s
radar.TiltAngle = 5.00000e-01; % deg
radar.TransmitAzimuthBeamwidth = 2;
radar.UnambiguousRange = 2.14137e+04;

% Convert frequency to wavelength
radar.Wavelength = freq2wavelen(radar.Frequency); % m

% Calculate system noise
radar.SystemTemperature = radar.NoiseTemperature; % Kelvin

% Calculate angular resolution
radar.EffectiveAzRes = effbeamwidth(radar.AzimuthBeamwidth(1),radar.AzimuthBeamwidth(2));     % deg
radar.EffectiveElRes = effbeamwidth(radar.ElevationBeamwidth(1),radar.ElevationBeamwidth(2)); % deg
end

%%
% Radar environment
function env = radarEnvironment()
env.EarthModel = 'Flat';
env.EffectiveEarthRadius = Inf; % m
env.PrecipitationMaxRange = 20000;
env.PrecipitationMinRange = 0;
env.RainPercentage = 1.00000e-02;
env.RainRate = 16;
env.RefractionExponent = 0;
env.RefractiveIndex = 1;
env.SurfaceHeightStandardDeviation = 0; % m
env.SurfaceRefractivity = 0;
end

%%
% Radar target
function target = radarTarget(radar,env,rangeLimits)
target.ElevationAngle = 5.00000e-01;
target.RCS = 1; % mÂ²
target.SwerlingCase = 'Swerling1';

% Calculate target position ranges
numTargetPositions = 1000;
target.ranges = linspace(rangeLimits(1),rangeLimits(2),numTargetPositions).'; % m
target.validRngIdxs = getValidRangeIdxs(radar,target,env);

% Calculate target height
target.Height = el2height(target.ElevationAngle,radar.Height,target.ranges, ...
    env.EarthModel,env.EffectiveEarthRadius); % m
end

%%
% Calculate propagation factor
function Fprop = propagationFactor(radar,target)
freqRange = [0.95*radar.Frequency 1.05*radar.Frequency];
patternAnglesEl = linspace(-90,90,361);
hTxRx = phased.SincAntennaElement('FrequencyRange',freqRange, ...
    'Beamwidth',[radar.AzimuthBeamwidth(1) radar.ElevationBeamwidth(1)]);
patternTxRxdB = pattern(hTxRx,radar.Frequency,0,patternAnglesEl,'Type','powerdb');
idxs = target.validRngIdxs;
elevationAngles = target.ElevationAngle*ones(size(idxs));
thetaDiff = mod(((elevationAngles - radar.TiltAngle) + 90),180) - 90;
apatternTxRx2 = interp1(patternAnglesEl,patternTxRxdB,thetaDiff).';
apatternTxRx1 = interp1(patternAnglesEl,patternTxRxdB,0).';
Fpattern = -Inf(numel(target.ranges),2);
Fpattern(idxs,:) = (apatternTxRx2.' - apatternTxRx1)*ones(1,2);
Fprop = Fpattern; % dB
end

%%
% Calculate environmental losses
function [Lgas,Llens,Lprecipitation] = atmosphericLosses(radar,env,target)
% Calculate atmospheric gas loss
Lgas = zeros(numel(target.ranges),1);
% Calculate lens effect loss
Llens = zeros(numel(target.ranges),1);
% Calculate precipitation loss
% Path loss due to rain. Valid for frequencies in range of 1 to 1000 GHz, inclusive. Not recommended for slant path propagation.
Lprecipitation = zeros(numel(target.ranges),1);
idxPrecipitation = target.ranges >= env.PrecipitationMinRange & target.validRngIdxs;
if any(idxPrecipitation)
    rangeExtentMax = env.PrecipitationMaxRange - env.PrecipitationMinRange;
    rangeExtent = target.ranges(idxPrecipitation) - env.PrecipitationMinRange;
    rangeExtent = min([rangeExtent,rangeExtentMax.*ones(numel(rangeExtent),1)],[],2);
    Lrain = rainpl(rangeExtent,radar.Frequency, ...
        env.RainRate,target.ElevationAngle, ...
        radar.PolarizationAngle,env.RainPercentage);
    Lprecipitation(idxPrecipitation) = Lrain;
end

end

%%
% Calculate range-dependent factors
function Fcustom = rangeDependentLosses(radar,target)
Fbeamdwell = beamdwellfactor(target.ranges,radar.TransmitAzimuthBeamwidth,radar.ScanRate);
Fcustom = Fbeamdwell; % dB
end


%%
% Get indices of geometrically valid ranges
function idxs = getValidRangeIdxs(radar,target,env)
anht = radar.Height + 2*env.SurfaceHeightStandardDeviation;
tgtht = inf;
minRng = 0;
maxRng = 2*env.EffectiveEarthRadius + tgtht + anht;
idxs = (target.ranges >= minRng & target.ranges <= maxRng);
end

%%
% Effective detectability factor for the selected radar
function [Dx,Dc,componentNames,processingGain] = effectiveDetectability(Pd,radar,target)
Pfa = radar.Pfa;
[Dc,componentNames] = detectabilityComponents(Pd,Pfa,radar.NumNonCoherentPulses,target.SwerlingCase,radar);
Dx = sum(Dc,2);
[~,pd,pfa] = binaryintloss(Pd,Pfa,radar.NumCPIs,radar.MNumCPIs);
pd = max(pd,0.100000);
pfa = min(pfa,0.001000);
Dccpi = detectabilityComponents(pd,pfa,radar.NumNonCoherentPulses,target.SwerlingCase,radar);
Gcpi = sum(Dccpi,2) - Dx;
Dx = Dx + Gcpi;
Dc = [Dc Gcpi];
componentNames = [componentNames 'CPI integration gain'];
processingGain = -sum(Dc(:,2:end),2);
end

%%
% Losses and gains included in the detectability factor
function [Dc,names] = detectabilityComponents(Pd,Pfa,N,SW,radar)
% Single-pulse steady target
D01 = detectability(Pd,Pfa,1,'Swerling0');
% Fluctuation loss
Lf = detectability(Pd,Pfa,N,SW) - detectability(Pd,Pfa,N,'Swerling0');
% Coherent integration gain
Gci = -pow2db(radar.NumCoherentPulses)*ones(numel(Pd),1);
% Eclipsing loss
Leclipsing = eclipsingloss(Pd,Pfa,N,radar.DutyCycle,SW);
% Beam shape loss
Lbeam = beamloss(true);
Lbeam = Lbeam*ones(numel(Pd),1);

Dc = [D01 Lf Gci Leclipsing Lbeam];
names = {'Single-pulse steady target' 'Fluctuation loss' 'Coherent integration gain' 'Eclipsing loss' 'Beam shape loss'};
end

%%
% Set limits of the y axis for environmental losses plots
function setYLims(ax,x)
idx = isfinite(x);
minx = min(x(idx), [], 'all');
if isempty(minx)
    minx = 0;
end
maxx = max(x(idx), [], 'all');
if isempty(maxx)
    maxx = 0;
end
d = max((maxx - minx)/10, 0.1);
ylim(ax, [minx - d maxx + d]);
end
